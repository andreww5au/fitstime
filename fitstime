#!/usr/bin/python

import sys
import string

import parseing
import fits
import coords

basefield = 'HJD_Calc'       #The base julian day field to use for output times
                             #The default, HJD_Calc, is derived from the best date
                             #and time fields, plus half the exptime, plus the 
                             #heliocentric offset.
#These can be changed to either +1 or -1 by command line arguments
hcorr=0   #Don't add or subtract the heliocentric correction to the base field 
ecorr=0   #Don't add or subtract half the exptime to the base field result
mcorr=0   #Any extra modifier, generally +/- 0.5 for broken JD/MJD conversions



usage="""FITS header time analysis - Andrew Williams
usage:  analyse.py [-h|-help|--help]  OR
        analyse.py [options] [filename] [filename] ...

where options can be:
-s, -S, --show   Give a full analysis of all time fields in the header,
                 and how they relate. Note that if this is specified, all
                 of the time-offset parameters are ignored, and the result
                 will be an analysis of the times IN the FITS header, not
                 corrected and output for use.

=[fieldname]     The base header field to use for output time, subject to the
                 offsets described below. The fieldname can be HJD_Calc, HJD,
                 JD, MJD, or MJD-OBS, and all have previously been converted
                 to full Julian day numbers.
                 The default, HJD_Calc, is not from the FITS header directly,
                 but calculated from the best available date and time fields
                 in the header, plus the heliocentric offset, and half the
                 exposure time.

[+|-][hel|exp]   A plus or minus, then 'hel' or 'exp' (or similar). Add or
                 subtract either the heliocentric correction, or half the
                 exposure time, to get the final output time for each image.
                 Any word containin 'hel' or 'exp' will do,
                 eg "+Hel.Corr. -Exptime/2"

[+|-][number]    An arbitrary offset to add to get the final output time for
                 each image. Must have a leading plus or minus sign. Typically
                 +0.5 or -0.5 to correct for unknown original MJD and MJD-OBS
                 offsets in the FITS header.

Typically you would do 'analyse.py --show *.fits' to examine the time fields
present in your images, and check them for consistency. Normally, you could
then 'analyse.py *.fits > times.txt' to produce a sorted HJD-midpoint time
list. 

If you see from the analysis output that a different field (eg JD) produces 
midpoint-HJD times, or you wish to apply an offset, then specify this on the 
command line. For example, if there is no date/time to get HJD_Calc, you might
want to specify 'analyse.py =MJD-OBS +hel +exp -0.5 *.fits > times.txt'.
"""

def cmpconf(a,b):
  """compare a and b based on the confidence level of the tuple, used in sorting"""
  return -cmp(a[2],b[2])


def getra(ras, verbose=1):
  """Extract the best RA from the values in the FITS header. Guess at 18h if none provided"""
  if ras:
    ras.sort(cmpconf)
    raval=ras[0][0]
    rafield=ras[0][1]
    if verbose and (len(ras)>1):
      if (raval-ras[1][0]) > 1e-2:         #We only care about RAs for HJD calculations
        print rafield+" and "+ras[1][1]+" disagree, using "+rafield+"="+coords.sexstring(raval,':')
    return raval,rafield
  else:
    if verbose:
      print "No detected RA field in header, assuming 18h for HJD calculations"
    return 18.0, "guess"


def getdec(decs, verbose=1):
  """Extract the best DEC from the values in the FITS header. Guess at -28d if none provided"""
  if decs:
    decs.sort(cmpconf)
    decval=decs[0][0]
    decfield=decs[0][1]
    if verbose and (len(decs)>1):
      if (decval-decs[1][0]) > 1e-2:         #We only care about DECs for HJD calculations
        print decfield+" and "+decs[1][1]+" disagree, using "+decfield+"="+coords.sexstring(decval,':')
    return decval,decfield
  else:
    if verbose:
      print "No detected DEC field in header, assuming -28d for HJD calculations"
    return -28.0,"guess"


def getdate(dates, verbose=1):
  """Extract the best date from the values in the FITS header. Return None if none provided"""
  if dates:
    dates.sort(cmpconf)
    dateval=dates[0][0]
    datefield=dates[0][1]
    datecon=dates[0][2]
    if verbose and (len(dates)>1):
      jd1 = coords.juldate(data=(dateval[0], dateval[1], int(dateval[2]), 0,0,0, 0,0,0))
      d2 = dates[1][0]
      jd2 = coords.juldate(data=(d2[0], d2[1], int(d2[2]), 0,0,0, 0,0,0))
      if ((jd1-jd2) > 1e-2) and (dates[1][2]>0):     #If dates differ by >1day, and confidence>0    
        print datefield+" and "+dates[1][1]+" disagree, using "+datefield+"="+parseing.ptuple(dateval,':')
    return dateval,datefield
  else:
    if verbose:
      print "No detected date field in header"
    return None,"None"


def gettime(times, verbose=1):
  """Extract the best UT time from the values in the FITS header. Return None if none provided"""
  if times:
    times.sort(cmpconf)
    timeval=times[0][0]
    timefield=times[0][1]
    timecon=times[0][2]
    if verbose and (len(times)>1):
      t1 = timeval[0]*3600 + timeval[1]*60 + timeval[2]     #in seconds
      t2 = times[1][0][0]*3600 + times[1][0][1]*60 + times[1][0][2]  #in seconds
      if ((t1-t2) > 10) and (times[1][2]>0):       #If times differ by >10sec, and confidence>0
        print timefield+" and "+times[1][1]+" disagree, using "+timefield+"="+parseing.ptuple(timeval,':')
    return timeval,timefield
  else:
    if verbose:
      print "No detected time field in header"
    return None,"None"


def getjd(jds, verbose=1):
  """Extract the best JD from the values in the FITS header. Return None if none provided"""
  if jds:
    jds.sort(cmpconf)
    jdval=jds[0][0]
    jdfield=jds[0][1]
    return jdval,jdfield
  else:
    return None,"None"


def getexptime(exptimes, verbose=1):
  """Extract the best JD from the values in the FITS header. Return None if none provided"""
  if exptimes:
    exptimes.sort(cmpconf)
    exptimeval=exptimes[0][0]
    exptimefield=exptimes[0][1]
    return exptimeval,exptimefield
  else:
    return None,"None"


def getequinox(equinoxes, verbose=1):
  """Extract the best equinox of coordinates from the values in the FITS header. Return 2000 if
     none provided
  """
  if equinoxes:
    equinoxes.sort(cmpconf)
    equinoxval = equinoxes[0][0]
    equinoxfield = equinoxes[0][1]
    return equinoxval,equinoxfield
  else:
    if verbose:
      print "No equinox or epoch of coordinates in FITS header, assuming 2000"
    return 2000.0,"guess"
  

def findtime(fname=None, verbose=1):
  try:
    f = fits.FITS(fname,'h')
    dates,times,jds,hjds,ras,decs,equinoxes,exptimes = parseing.parseheader(f.headers,f.comments)

    #parseheader returns lists of all values in each category (all dates, all ras, etc). Each list
    #is composed of tuples, being (value, field, confidence), where value is the number, field is 
    #a string containing the name of the FITS header field it was derived from, and confidence
    #is a number from 0 to ~200 containing the 'confidence' that that field is valid'. 

  except AssertionError:
    print "#Error opening or parseing FITS headers in file: "+fname
    sys.excepthook(*sys.exc_info())
    print
    return None

  if verbose:
    print "\nFinding time in: "+fname

  fdate,fdatefield = getdate(dates, verbose=verbose)
  ftime,ftimefield = gettime(times, verbose=verbose)
  fjd,fjdfield = getjd(jds+hjds, verbose=verbose)        #Grab best value as an initial guess if no date
  fra,frafield = getra(ras, verbose=verbose)
  fdec,fdecfield = getdec(decs, verbose=verbose)
  fequinox,fequinoxfield = getequinox(equinoxes, verbose=verbose)
  fexptime,fexptimefield = getexptime(exptimes, verbose=verbose)

  #Above calls extract the 'best' value in each category, by sorting based on confidence. If there is
  #more than one value for a category, compare the best and second best to check consistency. If there's
  #no value in a category, make up a reasonable default if appropriate (eg equinox of J2000).

  if fexptime:
    edelta = (fexptime/2.0)/86400       #Half the exposure time, in days
  else:
    if verbose:
      print "No exposure time information, can't verify or calculate time offsets"
    edelta = 0.0


  #Calculate HJD_Calc from the best date and time field, and find the heliocentric offset

  if fdate and ftime:
    cjd = coords.juldate(data=(fdate[0], fdate[1], int(fdate[2]),
                                 ftime[0], ftime[1], ftime[2], 0,0,0))
    chjd = coords.hjd(jd=cjd, ra=fra*15.0, dec=fdec)
    hdelta = chjd - cjd
    chjd = chjd + edelta
    hjds.insert(0,(chjd,"HJD_Calc",200))
    chjdfield = "(" + fdatefield + " & " + ftimefield + " + Hel.Corr. + Exptime/2)"
  elif fjd:
    ghjd = coords.hjd(jd=fjd, ra=fra*15.0, dec=fdec)
    hdelta = ghjd - fjd
  else:
    if verbose:
      print "No date and time, or any form of JD field. No idea how to find the time for this image..."
    chjdfield = "(no data)"
    return None


  if ((abs(hdelta)<1e-4) or (edelta<1e-4)) and verbose:
    print "Heliocentric or exptime/2 offset is less than 0.0001 days, can't reliably compare JD offsets"

  if verbose:
    print "Calculated HJD_Calc from "+chjdfield
    print "Hel.Corr = %8.6f     Exptime/2 = %8.6f" % (hdelta,edelta)

  hdl = [(-hdelta," -Hel.Corr."), (0.0,""), (+hdelta," +Hel.Corr.")]
  edl = [(-edelta," -Exptime/2"), (0.0,""), (+edelta," +Exptime/2")]
  mdl = [(-0.5," -0.5"), (0.0,""), (+0.5," +0.5")]

  jdict = {}
  for item in jds + hjds:
    jdict[item[1]] = item[0]

  jlist = jdict.keys()
  jlist.sort()
  

  #Now compare every field containing a JD or HJD value with every other, checking for close matches,
  #for all possible combinations of heliocentric, half-exptime and half-day offsets. For each match, 
  #store the match key names, a string specifying which offsets were used, and and error, in days.

  matches = {}
  for akey in jlist:
    matches[akey] = {}
    for bkey in jlist[jlist.index(akey)+1:]:
      ajd = jdict[akey]
      bjd = jdict[bkey]
      for hd in hdl:
        for ed in edl:
          for md in mdl:
            offset = hd[0] + ed[0] + md[0]
            offsetstring = hd[1] + ed[1] + md[1]
            if abs(ajd - (bjd+offset)) < 2e-4:       #About 17 seconds
              matches[akey][bkey] = ( offsetstring, ajd - (bjd+offset) )

  if verbose:
    for akey in jlist:
      print akey + " = " + `jdict[akey]`
      for bkey in matches[akey].keys():
        print " "*len(akey) + " = " + bkey + (matches[akey][bkey][0] + 
                            "   (" + str(round(matches[akey][bkey][1]*86400,2)) +" sec error)" )

  try:
    out = jdict[basefield]
  except KeyError:         #The base field isn't available
    return None
  out = out + hcorr*hdelta + ecorr*edelta + mcorr
  return out


####################################################################

#Main program

if __name__ == '__main__':
  args=sys.argv[1:]
  if not args:
    print usage
    sys.exit()

  verbose=0     #Don't verbosely analyse the file, just print "filename time"
  parseing.dateorder=None      #Don't override best guess at date order - can also be 'DMY' or 'YMD'

  signs={'-':-1, '+':+1}

  files=[]
  for ar in args:
    if ar=='-s' or ar=='-S' or ar=='-show' or ar=='--show':
      verbose=1
    elif ar=='-h' or ar=='-help' or ar=='--help':
      print usage
      sys.exit()
    elif ar=='-DMY' or ar=='-dmy' or ar=='--DMY' or ar=='--dmy':
      parseing.dateorder='DMY'
    elif ar=='-YMD' or ar=='-ymd' or ar=='--YMD' or ar=='--ymd':
      parseing.dateorder='YMD'
    elif ar[0]=='=':
      ac=ar[1:]
      if not ac:
        sys.exit("Invalid option '=', must specify a field name after the '='")
      ac=string.upper(ac)
      if ac=='HJD_CALC':
        basefield='HJD_Calc'
      elif ac=='HJD' or ac=='JD' or ac=='MJD' or ac=='MJD-OBS':
        basefield=ac
      else:
        sys.exit("Invalid base field '" + ac + "'")
    elif ar[0]=='-' or ar[0]=='+':
      scorr=signs[ar[0]]
      ac=ar[1:]
      if not ac:
        break             #If we're passed a lone + or - arg, treat rest of command line as files
      ac=string.upper(ac)
      if string.find(ac,'HEL')>-1:
        hcorr=scorr
      elif string.find(ac,'EXP')>-1:
        ecorr=scorr
      else:
        try:
          mcorr=float(ar)
        except:
          mcorr=0            #Whatever it is after the +/- it's not a number or a valid modifier
          sys.exit("Unknown uption '" + ar + "'")
    else:
      files.append(ar)

  for f in files:
    print f,
    t=findtime(f,verbose)
    if t:
      print t
    else:
      print "***No Data***"
  
